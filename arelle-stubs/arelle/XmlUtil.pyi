from _typeshed import Incomplete
from arelle.ModelInstanceObject import ModelContext as ModelContext, ModelUnit as ModelUnit
from arelle.ModelObject import ModelObject as ModelObject
from arelle.ModelValue import QName as QName, qname as qname, tzinfoStr as tzinfoStr
from arelle.PrototypeDtsObject import PrototypeElementTree as PrototypeElementTree, PrototypeObject as PrototypeObject
from arelle.XbrlConst import ixbrlAll as ixbrlAll, qnLinkFootnote as qnLinkFootnote, xhtml as xhtml, xml as xml, xsd as xsd
from collections.abc import Generator
from typing import Any

htmlEltUriAttrs: Incomplete
resolveHtmlUri: Incomplete
datetimePattern: Incomplete
xmlEncodingPattern: Incomplete
xpointerFragmentIdentifierPattern: Incomplete
xmlnsStripPattern: Incomplete
nonSpacePattern: Incomplete

def xmlns(element, prefix) -> Any: ...
def xmlnsprefix(element, ns) -> Any: ...
def targetNamespace(element): ...
def schemaLocation(element, namespace, returnElement: bool = ...): ...
def clarkNotationToPrefixNsLocalname(element, clarkName, isAttribute: bool = ...): ...
def clarkNotationToPrefixedName(element, clarkName, isAttribute: bool = ...): ...
def prefixedNameToNamespaceLocalname(element, prefixedName, defaultNsmap: Incomplete | None = ...): ...
def prefixedNameToClarkNotation(element, prefixedName): ...
def encoding(xml, default: str = ...): ...
def text(element): ...
def childText(element, childNamespaceURIs, childLocalNames): ...
def textNotStripped(element): ...
def innerText(element, ixExclude: bool = ..., ixEscape: Incomplete | None = ..., ixContinuation: bool = ..., ixResolveUris: bool = ..., strip: bool = ...): ...
def innerTextList(element, ixExclude: bool = ..., ixEscape: Incomplete | None = ..., ixContinuation: bool = ..., ixResolveUris: bool = ...): ...
def innerTextNodes(element, ixExclude, ixEscape, ixContinuation, ixResolveUris) -> Generator[Incomplete, None, None]: ...
def escapedNode(elt, start, empty, ixEscape, ixResolveUris): ...
def escapedText(text): ...
def collapseWhitespace(s): ...
def parentId(element, parentNamespaceURI, parentLocalName): ...
def hasChild(element, childNamespaceURI, childLocalNames): ...
def hasDescendant(element, descendantNamespaceURI, descendantLocalNames): ...
def hasAncestor(element, ancestorNamespaceURI, ancestorLocalNames): ...
def ancestor(element, ancestorNamespaceURI, ancestorLocalNames): ...
def parent(element, parentNamespaceURI: Incomplete | None = ..., parentLocalNames: Incomplete | None = ..., ixTarget: bool = ...): ...
def ancestors(element, ancestorNamespaceURI: Incomplete | None = ..., ancestorLocalNames: Incomplete | None = ...): ...
def ancestorOrSelfAttr(element, attrClarkName): ...
def childAttr(element, childNamespaceURI, childLocalNames, attrClarkName): ...
def descendantAttr(element, childNamespaceURI, childLocalNames, attrClarkName, attrName: Incomplete | None = ..., attrValue: Incomplete | None = ...) -> Any: ...
def children(element, childNamespaceURIs, childLocalNames, ixTarget: bool = ...) -> list[Union[ModelObject, ModelContext, ModelUnit]]: ...
def child(element, childNamespaceURI: Incomplete | None = ..., childLocalNames=...): ...
def lastChild(element, childNamespaceURI: Incomplete | None = ..., childLocalNames=...): ...
def previousSiblingElement(element): ...
def nextSiblingElement(element): ...
def childrenAttrs(element, childNamespaceURI, childLocalNames, attrLocalName): ...
def descendant(element, descendantNamespaceURI, descendantLocalNames, attrName: Incomplete | None = ..., attrValue: Incomplete | None = ...) -> Any: ...
def descendants(element, descendantNamespaceURI, descendantLocalNames, attrName: Incomplete | None = ..., attrValue: Incomplete | None = ..., breakOnFirst: bool = ..., ixTarget: bool = ...): ...
def isDescendantOf(element, ancestorElement): ...
def schemaDescendantsNames(element, descendantNamespaceURI, descendantLocalName, qnames: Incomplete | None = ...): ...
def schemaDescendant(element, descendantNamespaceURI, descendantLocalName, name): ...
def schemaBaseTypeDerivedFrom(element): ...
def schemaFacets(element, facetTags, facets: Incomplete | None = ...): ...
def schemaAttributesGroups(element, attributes: Incomplete | None = ..., attributeWildcards: Incomplete | None = ..., attributeGroups: Incomplete | None = ...): ...
def emptyContentModel(element): ...
def addChild(parent, childName1, childName2: Incomplete | None = ..., attributes: Incomplete | None = ..., text: Incomplete | None = ..., afterSibling: Incomplete | None = ..., beforeSibling: Incomplete | None = ..., appendChild: bool = ...): ...
def copyNodes(parent, elts) -> None: ...
def copyChildren(parent, elt) -> None: ...
def copyIxFootnoteHtml(srcXml, tgtHtml, targetModelDocument: Incomplete | None = ..., withText: bool = ..., isContinChainElt: bool = ..., tgtStack: Incomplete | None = ..., srcLevel: int = ...) -> None: ...
def addComment(parent, commentText) -> None: ...
def addProcessingInstruction(parent, piTarget, piText, insertBeforeChildElements: bool = ..., insertBeforeParentElement: bool = ...) -> None: ...
def addQnameValue(modelDocument, qnameValue): ...
def setXmlns(modelDocument, prefix, namespaceURI) -> None: ...
def sortKey(parentElement, childNamespaceUri, childLocalNames, childAttributeName: Incomplete | None = ..., qnames: bool = ...): ...

DATETIME_MINYEAR: Incomplete
DATETIME_MAXYEAR: Incomplete

def tzinfo(tz): ...
def datetimeValue(element, addOneDay: bool = ..., none: Incomplete | None = ...): ...
def dateunionValue(datetimeValue, subtractOneDay: bool = ..., dateOnlyHour: Incomplete | None = ...): ...
def xpointerSchemes(fragmentIdentifier): ...
def xpointerElement(modelDocument, fragmentIdentifier): ...
def elementFragmentIdentifier(element): ...
def elementIndex(element): ...
def elementChildSequence(element): ...
def elementTagnamesPath(element): ...
def xmlstring(elt, stripXmlns: bool = ..., prettyPrint: bool = ..., contentsOnly: bool = ..., includeText: bool = ...): ...
def writexml(writer, node, encoding: Incomplete | None = ..., indent: str = ..., xmlcharrefreplace: bool = ..., parentNsmap: Incomplete | None = ...) -> None: ...
