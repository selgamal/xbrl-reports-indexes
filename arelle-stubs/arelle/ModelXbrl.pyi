from _typeshed import Incomplete
from arelle import ModelValue as ModelValue, UrlUtil as UrlUtil, XbrlConst as XbrlConst, XmlUtil as XmlUtil, XmlValidate as XmlValidate
from arelle.FileSource import FileNamedStringIO as FileNamedStringIO
from arelle.Locale import format_string as format_string
from arelle.ModelInstanceObject import ModelContext as ModelContext
from arelle.ModelObject import ModelObject as ModelObject, ObjectPropertyViewWrapper as ObjectPropertyViewWrapper
from arelle.ModelRelationshipSet import ModelRelationshipSet as ModelRelationshipSetClass
from arelle.PluginManager import pluginClassMethods as pluginClassMethods
from arelle.PrototypeInstanceObject import DimValuePrototype as DimValuePrototype, FactPrototype as FactPrototype
from arelle.PythonUtil import flattenSequence as flattenSequence
from arelle.UrlUtil import isHttpUrl as isHttpUrl
from arelle.ValidateXbrlDimensions import isFactDimensionallyValid as isFactDimensionallyValid
from typing import Any

ModelFact: Incomplete
profileStatNumber: int
AUTO_LOCATE_ELEMENT: str
DEFAULT: Incomplete
NONDEFAULT: Incomplete
DEFAULTorNONDEFAULT: Incomplete
EMPTY_TUPLE: Incomplete

def load(modelManager, url, nextaction: Incomplete | None = ..., base: Incomplete | None = ..., useFileSource: Incomplete | None = ..., errorCaptureLevel: Incomplete | None = ..., **kwargs): ...
def create(modelManager, newDocumentType: Incomplete | None = ..., url: Incomplete | None = ..., schemaRefs: Incomplete | None = ..., createModelDocument: bool = ..., isEntry: bool = ..., errorCaptureLevel: Incomplete | None = ..., initialXml: Incomplete | None = ..., initialComment: Incomplete | None = ..., base: Incomplete | None = ..., discover: bool = ...): ...
def loadSchemalocatedSchemas(modelXbrl) -> None: ...

class ModelXbrl:
    contexts: dict[Any, Any]
    dimensionDefaultConcepts: dict
    ixdsHtmlElements: list
    isDimensionsValidated: bool
    uriDir: str
    targetRelationships: Any
    qnameDimensionContextElement: dict
    modelManager: Incomplete
    skipDTS: Incomplete
    def __init__(self, modelManager, errorCaptureLevel: Incomplete | None = ...) -> None: ...
    uuid: Incomplete
    namespaceDocs: Incomplete
    urlDocs: Incomplete
    urlUnloadableDocs: Incomplete
    errorCaptureLevel: Incomplete
    errors: Incomplete
    logCount: Incomplete
    arcroleTypes: Incomplete
    roleTypes: Incomplete
    qnameConcepts: Incomplete
    nameConcepts: Incomplete
    qnameAttributes: Incomplete
    qnameAttributeGroups: Incomplete
    qnameGroupDefinitions: Incomplete
    qnameTypes: Incomplete
    baseSets: Incomplete
    relationshipSets: Incomplete
    qnameDimensionDefaults: Incomplete
    facts: Incomplete
    factsInInstance: Incomplete
    undefinedFacts: Incomplete
    units: Incomplete
    modelObjects: Incomplete
    qnameParameters: Incomplete
    modelVariableSets: Incomplete
    modelConsistencyAssertions: Incomplete
    modelCustomFunctionSignatures: Incomplete
    modelCustomFunctionImplementations: Incomplete
    modelRenderingTables: Incomplete
    views: Incomplete
    langs: Incomplete
    labelroles: Incomplete
    hasXDT: bool
    hasTableRendering: bool
    hasTableIndexing: bool
    hasFormulae: bool
    formulaOutputInstance: Incomplete
    logger: Incomplete
    logRefObjectProperties: Incomplete
    logRefHasPluginAttrs: Incomplete
    logRefHasPluginProperties: Incomplete
    logRefFileRelUris: Incomplete
    profileStats: Incomplete
    schemaDocsToValidate: Incomplete
    modelXbrl: Incomplete
    arelleUnitTests: Incomplete
    def init(self, keepViews: bool = ..., errorCaptureLevel: Incomplete | None = ...) -> None: ...
    def close(self) -> None: ...
    @property
    def isClosed(self): ...
    modelDocument: Incomplete
    def reload(self, nextaction, reloadCache: bool = ...) -> None: ...
    def closeViews(self) -> None: ...
    @property
    def displayUri(self): ...
    def relationshipSet(self, arcrole, linkrole: Incomplete | None = ..., linkqname: Incomplete | None = ..., arcqname: Incomplete | None = ..., includeProhibits: bool = ...) -> ModelRelationshipSetClass: ...
    def baseSetModelLink(self, linkElement): ...
    def roleUriTitle(self, roleURI): ...
    def roleTypeDefinition(self, roleURI, lang: Incomplete | None = ...) -> str: ...
    def roleTypeName(self, roleURI, lang: Incomplete | None = ...): ...
    def matchSubstitutionGroup(self, elementQname, subsGrpMatchTable): ...
    def isInSubstitutionGroup(self, elementQname, subsGrpQnames) -> bool: ...
    fileSource: Incomplete
    closeFileSource: bool
    def createInstance(self, url: Incomplete | None = ...) -> None: ...
    def saveInstance(self, **kwargs) -> None: ...
    @property
    def prefixedNamespaces(self): ...
    def matchContext(self, entityIdentScheme, entityIdentValue, periodType, periodStart, periodEndInstant, dims, segOCCs, scenOCCs): ...
    def createContext(self, entityIdentScheme, entityIdentValue, periodType, periodStart, periodEndInstant, priItem, dims, segOCCs, scenOCCs, afterSibling: Incomplete | None = ..., beforeSibling: Incomplete | None = ..., id: Incomplete | None = ...): ...
    def matchUnit(self, multiplyBy, divideBy): ...
    def createUnit(self, multiplyBy, divideBy, afterSibling: Incomplete | None = ..., beforeSibling: Incomplete | None = ..., id: Incomplete | None = ...): ...
    @property
    def nonNilFactsInInstance(self): ...
    @property
    def factsByQname(self): ...
    @property
    def factsByLocalName(self): ...
    def factsByDatatype(self, notStrict, typeQname): ...
    def factsByPeriodType(self, periodType): ...
    def factsByDimMemQname(self, dimQname, memQname: Incomplete | None = ...): ...
    @property
    def contextsInUse(self): ...
    @property
    def dimensionsInUse(self): ...
    def matchFact(self, otherFact, unmatchedFactsStack: Incomplete | None = ..., deemP0inf: bool = ..., matchId: bool = ..., matchLang: bool = ...): ...
    makeelementParentModelObject: Incomplete
    def createFact(self, conceptQname, attributes: Incomplete | None = ..., text: Incomplete | None = ..., parent: Incomplete | None = ..., afterSibling: Incomplete | None = ..., beforeSibling: Incomplete | None = ..., validate: bool = ...): ...
    def setIsModified(self) -> None: ...
    def isModified(self): ...
    def modelObject(self, objectId): ...
    def viewModelObject(self, objectId: Union[str, int]) -> None: ...
    def effectiveMessageCode(self, messageCodes): ...
    def isLoggingEffectiveFor(self, **kwargs): ...
    def logArguments(self, messageCode, msg, codedArgs): ...
    def loggableValue(self, argValue): ...
    def debug(self, codes, msg, **args) -> None: ...
    def info(self, codes, msg, **args) -> None: ...
    def warning(self, codes, msg, **args) -> None: ...
    def log(self, level, codes, msg, **args) -> None: ...
    def error(self, codes: Union[str, tuple[str, ...]], msg: str, **args) -> None: ...
    def exception(self, codes, msg, **args) -> None: ...
    def logProfileStats(self): ...
    def profileStat(self, name: Incomplete | None = ..., stat: Incomplete | None = ...) -> None: ...
    def profileActivity(self, activityCompleted: Incomplete | None = ..., minTimeToShow: int = ...) -> None: ...
    def saveDTSpackage(self) -> None: ...
